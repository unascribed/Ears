<!DOCTYPE html>
<!--
MIT License

Copyright (c) 2021 Una Thompson (unascribed)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<html>
<head>
	<meta charset="utf-8">
	<title>Ears Skin Manipulator</title>
	<script>
	/*
	@licstart  The following is the entire license notice for the 
	JavaScript code in this page.

	MIT License

	Copyright (c) 2021 Una Thompson (unascribed)

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.

	@licend  The above is the entire license notice
	for the JavaScript code in this page.
	*/
	</script>
	<style>
		body {
			font-family: system-ui, sans-serif;
			background: #1A2327;
			color: #ECEFF1;
			line-height: 1.4;
		}
		body.loading {
			cursor: wait;
			background: #455A64;
		}
		body.loading:after {
			content: "One moment...";
			font-size: 32px;
			font-weight: bold;
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translateX(-50%) translateY(-50%);
		}
		body.loading .inner {
			pointer-events: none;
			opacity: 0.5;
		}
		.center {
			text-align: center !important;
		}
		.inner {
			max-width: 1280px;
			padding: 0 16px;
			padding-right: 512px;
			margin: 0 auto;
			box-sizing: border-box;
		}
		h1 small {
			font-weight: normal;
			font-size: 0.6em;
		}
		h2 small {
			font-weight: normal;
			font-size: 0.6em;
		}
		#skin, #wings {
			background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAIAQMAAAD+wSzIAAAABlBMVEVmZmaZmZmoZ+Z2AAAAD0lEQVQIW2PkZ4TADxAIABIoBAXF3RsYAAAAAElFTkSuQmCC');
		}
		#skin {
			image-rendering: -moz-crisp-edges;
			image-rendering: crisp-edges;
			image-rendering: pixelated;
			width: 128px;
			height: 128px;
		}
		#wings {
			image-rendering: -moz-crisp-edges;
			image-rendering: crisp-edges;
			image-rendering: pixelated;
			width: 24px;
			height: 24px;
		}
		#three {
			width: 512px;
			height: 896px;
			position: fixed;
			top: 16px;
			right: 0px;
		}
		@media(min-width: 1280px) {
			#three {
				right: calc(((100vw - 1280px) / 2) - 16px);
			}
		}
		td {
			padding: 2px;
		}
		.def-right td {
			text-align: right;
		}
		td input[type="number"], td input[type="range"], td select {
			width: 100%;
		}
		a:link {
			color: #0FA;
		}
		.notice {
			border-left: #F03 5px solid;
			padding: 8px;
			padding-left: 58px;
			background-image: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTEyLDIwQTgsOCAwIDAsMCAyMCwxMkE4LDggMCAwLDAgMTIsNEE4LDggMCAwLDAgNCwxMkE4LDggMCAwLDAgMTIsMjBNMTIsMkExMCwxMCAwIDAsMSAyMiwxMkExMCwxMCAwIDAsMSAxMiwyMkM2LjQ3LDIyIDIsMTcuNSAyLDEyQTEwLDEwIDAgMCwxIDEyLDJNMTIuNSw3VjEyLjI1TDE3LDE0LjkyTDE2LjI1LDE2LjE1TDExLDEzVjdIMTIuNVoiIGZpbGw9IiNGRkYiLz48L3N2Zz4K');
			background-position: 12px 12px;
			background-repeat: no-repeat;
			background-size: 32px 32px;
		}
		.notice.bug {
			background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCI+PHBhdGggZD0iTTIwIDhoLTIuODFjLS40NS0uOC0xLjA3LTEuNS0xLjgyLTJMMTcgNC40MSAxNS41OSAzbC0yLjE3IDIuMTdhNi4wMDIgNi4wMDIgMCAwMC0yLjgzIDBMOC40MSAzIDcgNC40MSA4LjYyIDZjLS43NS41LTEuMzYgMS4yMS0xLjgxIDJINHYyaDIuMDljLS4wNi4zMy0uMDkuNjYtLjA5IDF2MUg0djJoMnYxYzAgLjM0LjAzLjY3LjA5IDFINHYyaDIuODFBNS45ODggNS45ODggMCAwMDE1IDIwLjE4Yy45MS0uNTIgMS42Ny0xLjI4IDIuMTktMi4xOEgyMHYtMmgtMi4wOWMuMDYtLjMzLjA5LS42Ni4wOS0xdi0xaDJ2LTJoLTJ2LTFjMC0uMzQtLjAzLS42Ny0uMDktMUgyMFY4bS00IDdhNCA0IDAgMDEtNCA0IDQgNCAwIDAxLTQtNHYtNGE0IDQgMCAwMTQtNCA0IDQgMCAwMTQgNHY0bS0yLTV2MmgtNHYtMmg0bS00IDRoNHYyaC00di0yeiIgZmlsbD0iI0ZGRiIvPjwvc3ZnPgo=');
			border-left-color: #F80;
		}
		.notice.legacy {
			border-left-color: #AAA;
			background-image: none;
			padding-left: 16px;
		}
		.notice.info {
			background-image: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTExLDlIMTNWN0gxMU0xMiwyMEM3LjU5LDIwIDQsMTYuNDEgNCwxMkM0LDcuNTkgNy41OSw0IDEyLDRDMTYuNDEsNCAyMCw3LjU5IDIwLDEyQzIwLDE2LjQxIDE2LjQxLDIwIDEyLDIwTTEyLDJBMTAsMTAgMCAwLDAgMiwxMkExMCwxMCAwIDAsMCAxMiwyMkExMCwxMCAwIDAsMCAyMiwxMkExMCwxMCAwIDAsMCAxMiwyTTExLDE3SDEzVjExSDExVjE3WiIgZmlsbD0iI0ZGRiIvPjwvc3ZnPgo=');
			border-left-color: #0AF;
		}
		ul {
			margin: 0;
		}
		@media(prefers-color-scheme: light) {
			body {
				background: #ECEFF1;
				color: #1A2327;
			}
			body.loading {
				cursor: wait;
				background: #90A4AE;
			}
			a:link {
				color: #0A6;
			}
			.notice {
				background-image: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTEyLDIwQTgsOCAwIDAsMCAyMCwxMkE4LDggMCAwLDAgMTIsNEE4LDggMCAwLDAgNCwxMkE4LDggMCAwLDAgMTIsMjBNMTIsMkExMCwxMCAwIDAsMSAyMiwxMkExMCwxMCAwIDAsMSAxMiwyMkM2LjQ3LDIyIDIsMTcuNSAyLDEyQTEwLDEwIDAgMCwxIDEyLDJNMTIuNSw3VjEyLjI1TDE3LDE0LjkyTDE2LjI1LDE2LjE1TDExLDEzVjdIMTIuNVoiIGZpbGw9IiMwMDAiLz48L3N2Zz4K');
			}
			.notice.bug {
				background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCI+PHBhdGggZD0iTTIwIDhoLTIuODFjLS40NS0uOC0xLjA3LTEuNS0xLjgyLTJMMTcgNC40MSAxNS41OSAzbC0yLjE3IDIuMTdhNi4wMDIgNi4wMDIgMCAwMC0yLjgzIDBMOC40MSAzIDcgNC40MSA4LjYyIDZjLS43NS41LTEuMzYgMS4yMS0xLjgxIDJINHYyaDIuMDljLS4wNi4zMy0uMDkuNjYtLjA5IDF2MUg0djJoMnYxYzAgLjM0LjAzLjY3LjA5IDFINHYyaDIuODFBNS45ODggNS45ODggMCAwMDE1IDIwLjE4Yy45MS0uNTIgMS42Ny0xLjI4IDIuMTktMi4xOEgyMHYtMmgtMi4wOWMuMDYtLjMzLjA5LS42Ni4wOS0xdi0xaDJ2LTJoLTJ2LTFjMC0uMzQtLjAzLS42Ny0uMDktMUgyMFY4bS00IDdhNCA0IDAgMDEtNCA0IDQgNCAwIDAxLTQtNHYtNGE0IDQgMCAwMTQtNCA0IDQgMCAwMTQgNHY0bS0yLTV2MmgtNHYtMmg0bS00IDRoNHYyaC00di0yeiIgZmlsbD0iIzAwMCIvPjwvc3ZnPgo=');
			}
			.notice.legacy {
				background-image: none;
			}
			.notice.info {
				background-image: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTExLDlIMTNWN0gxMU0xMiwyMEM3LjU5LDIwIDQsMTYuNDEgNCwxMkM0LDcuNTkgNy41OSw0IDEyLDRDMTYuNDEsNCAyMCw3LjU5IDIwLDEyQzIwLDE2LjQxIDE2LjQxLDIwIDEyLDIwTTEyLDJBMTAsMTAgMCAwLDAgMiwxMkExMCwxMCAwIDAsMCAxMiwyMkExMCwxMCAwIDAsMCAyMiwxMkExMCwxMCAwIDAsMCAxMiwyTTExLDE3SDEzVjExSDExVjE3WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPgo=');
			}
		}
	</style>
</head>
<body>
	<noscript><b>You must enable JavaScript to use the manipulator.</b></noscript>
	<div class="inner">
		<div id="three"></div>
		<h1>Ears Skin Manipulator <small id="version"></small></h1>
		<p>
			Upload* a skin to get started. Legacy (pre-1.8, 64x32) skins will be converted to modern 64x64 skins.<br/><br/>
			<b>Once you're done, right-click the skin preview below and choose "Save image as..." to download it.</b><br/><br/>
			<b>This tool helps you to set up the "magic pixels" in your skin that are read by the Ears mod.</b> You can see it as the various colors on the left center of the skin shown below. <b><i style="color:#F44336">This means that in order for changes made here to apply, you must save the skin below and <a style="color:#F44336" href="https://www.minecraft.net/en-us/profile/skin" rel="nofollow">upload it to Mojang</a>!</i></b> If you do not do this, <i>no Ears features will appear in-game</i>. There is no in-game configuration GUI or anything for Ears, all the options are encoded into those magic pixels.
		</p>
		<input type="file" id="skin-upload" accept="image/png,.png"></input><br/><br/>
		Alternatively, you can <button id="sample">load a sample skin</button> which will change to demonstrate any options you select below.<br/>
		<div>
		<canvas id="skin" width="64" height="64"></canvas>
		</div>
		<small>* This entire thing is client-sided. You're not actually uploading or downloading anything, those are just the words people are familiar with.</small>
		<h2>Vanilla Skin Customization<br/>
		<small>Not stored in the skin. Only affects the render on the right.</small></h2>
		<table>
			<tr>
				<td><input id="slim-enabled" type="checkbox"><label for="slim-enabled"> Slim Arms</label></td>
			</tr>
			<tr>
				<td><input id="head2-enabled" type="checkbox" checked><label for="head2-enabled"> Hat</label></td>
				<td><input id="torso2-enabled" type="checkbox" checked><label for="torso2-enabled"> Jacket</label></td>
			</tr>
			<tr>
				<td><input id="left_arm2-enabled" type="checkbox" checked><label for="left_arm2-enabled"> Left Sleeve</label></td>
				<td><input id="right_arm2-enabled" type="checkbox" checked><label for="right_arm2-enabled"> Right Sleeve</label></td>
			</tr>
			<tr>
				<td><input id="left_leg2-enabled" type="checkbox" checked><label for="left_leg2-enabled"> Left Pants Leg</label></td>
				<td><input id="right_leg2-enabled" type="checkbox" checked><label for="right_leg2-enabled"> Right Pants Leg</label></td>
			</tr>
		</table>
		<h2>Ears Customization<br/>
		<small>Stored in the skin. Changing options here will update the magic pixels in the skin above.</small></h2>
		<input id="ears-enabled" type="checkbox"><label for="ears-enabled"> Enabled</label><br/><br/>
		<table class="def-right">
			<tr>
				<td>
					<label for="ear-mode">Ear Mode</label>
				</td>
				<td>
					<select disabled id="ear-mode">
						<option value="red">None</option>
						<option value="blue">Above</option>
						<option value="green">Sides</option>
						<option value="purple2">Out</option>
						<option value="cyan">Around</option>
						<option value="orange">Floppy</option>
						<option value="pink">Cross</option>
						<option value="purple">Behind (old, prefer Out)</option>
					</select>
				</td>
				<td>
					<label for="ear-anchor">Ear Anchor</label>
				</td>
				<td>
					<select disabled id="ear-anchor">
						<option value="blue">Center</option>
						<option value="green">Front</option>
						<option value="red">Back</option>
					</select>
				</td>
			</tr>
			<tr>
				<td>
					<label for="protrusions">Protrusions</label>
				</td>
				<td>
					<select disabled id="protrusions">
						<option value="red">None</option>
						<option value="green">Claws</option>
						<option value="purple">Horn</option>
						<option value="cyan">Claws &amp; Horn</option>
					</select>
				</td>
			</tr>
			<tr>
				<td>
					<label for="tail-mode">Tail Mode</label>
				</td>
				<td>
					<select disabled id="tail-mode">
						<option value="red">None</option>
						<option value="blue">Down</option>
						<option value="green">Back</option>
						<option value="purple">Up</option>
						<option value="orange">Vertical</option>
					</select>
				</td>
				<td>
					<label for="tail-segments">Tail Segments</label>
				</td>
				<td>
					<input id="tail-segments" type="number" min="1" max="4" step="1" value="1" disabled>
				</td>
			</tr>
			<tr>
				<td>
					Tail Bends
				</td>
				<td>
					<input id="tail-bend-0" type="range" disabled value="0" min="-90" max="90" step="15">
				</td>
				<td>
					<input id="tail-bend-1" type="range" disabled value="1" min="-90" max="90" step="15">
				</td>
				<td>
					<input id="tail-bend-2" type="range" disabled value="1" min="-90" max="90" step="15">
				</td>
				<td>
					<input id="tail-bend-3" type="range" disabled value="1" min="-90" max="90" step="15">
				</td>
			</tr>
			<tr>
				<td><input id="unlock-angles" disabled type="checkbox"><label for="unlock-angles"> Unlock</label></td>
				<td class="center">
					<span id="tail-bend-0-angle">0째</span><br/>
				</td>
				<td class="center">
					<span id="tail-bend-1-angle"></span>
				</td>
				<td class="center">
					<span id="tail-bend-2-angle"></span>
				</td>
				<td class="center">
					<span id="tail-bend-3-angle"></span>
				</td>
			</tr>
			<tr>
				<td>
					<input id="snout" disabled type="checkbox"><label for="snout"> Snout</label>
				</td>
				<td>
					<input id="snout-width" type="range" disabled value="1" min="1" max="7" step="1">
				</td>
				<td>
					<input id="snout-height" type="range" disabled value="1" min="1" max="4" step="1">
				</td>
				<td>
					<input id="snout-depth" type="range" disabled value="1" min="1" max="6" step="1">
				</td>
				<td>
					<input id="snout-offset" type="range" disabled value="0" min="0" max="8" step="1">
				</td>
			</tr>
			<tr>
				<td></td>
				<td class="center">Width</td>
				<td class="center">Height</td>
				<td class="center">Length</td>
				<td class="center">Offset</td>
			</tr>
			<tr>
				<td></td>
				<td class="center" colspan="4" id="snout-size" style="visibility: hidden">
					<span id="snout-width-value">1</span>x<span id="snout-height-value">1</span>x<span id="snout-depth-value">1</span>-0,<span id="snout-offset-value">0</span>
				</td>
				</td>
			</tr>
			<tr id="chest-outer" style="display: none">
				<td>
					<input id="chest" disabled type="checkbox"><label for="chest"> Chest</label>
				</td>
				<td>
					<input id="chest-size" type="range" disabled value="1" min="1" max="128" step="1">
				</td>
			</tr>
			<tr>
				<td>
					<label for="wings-mode">Wings Mode</label>
				</td>
				<td>
					<select disabled id="wings-mode">
						<option value="red">None</option>
						<option value="pink">Symmetric Dual</option>
						<option value="green">Symmetric Single</option>
						<option value="cyan">Asymmetric Single (Left)</option>
						<option value="orange">Asymmetric Single (Right)</option>
					</select>
				</td>
				<td style="text-align: left"><canvas id="wings" width="12" height="12"></canvas></td>
			</tr>
		</table>
		<table>
			<tr>
				<td></td>
				<td>
				<input disabled type="file" id="wing-upload" accept="image/png,.png"></input><br/>
				</td>
			</tr>
			<tr>
			<td></td>
				<td style="text-align: left; vertical-align: top"><small>Must be 12x12</small></td>
			</tr>
		</table>
		<br/>
		<div class="notice info" style="display: none;margin-bottom:8px" id="alfalfa-notice">
			<b><i>There is data encoded in the alpha channel of the skin.</i></b><br/>
			This may cause some skin viewers to show corrupted pixels, but will not affect the skin's
			appearance in-game.
			<div id="alfalfa-notice-unneeded">
				<br/>
				However, no options are enabled that use this data. You can <button id="remove-alfalfa">remove it</button> if you wish.
			</div>
		</div>
		<div class="notice legacy" style="display: none;margin-bottom:8px" id="req-121-notice">
			<b><i>Selected options require new features added in v1.2.1.</i></b><br/>
			Before v1.2.1, Cross ears mode will not render.
		</div>
		<div class="notice legacy" style="display: none;margin-bottom:8px" id="req-122-notice">
			<b><i>Selected options require new features added in v1.2.2.</i></b><br/>
			Before v1.2.2, any custom first tail bend angle will be treated as 0째.
		</div>
		<div class="notice legacy" style="display: none;margin-bottom:8px" id="req-123-notice">
			<b><i>Selected options require new features added in v1.2.3.</i></b><br/>
			Before v1.2.3, Out ears mode will not render. <span id="out-anchor-back">As you're using
			an Ear Anchor of "Back", you may use the legacy Behind ears mode instead for compatibility.</span>
		</div>
		<div class="notice legacy" style="display: none;margin-bottom:8px" id="req-124-notice">
			<b><i>Selected options require new features added in v1.2.4.</i></b><br/>
			Before v1.2.4, Vertical tail mode will not render.
		</div>
		<div class="notice" style="display: none;margin-bottom:8px" id="req-130-notice">
			<b><i>Selected options require new features added in v1.3.0.</i></b><br/>
			Before v1.3.0, <span id="req-130-snouts">snouts</span><span id="req-130-and"> and </span><span id="req-130-chest">chests</span> will not render.
		</div>
		<div class="notice" style="display: none;margin-bottom:8px" id="req-140-notice">
			<b><i>Selected options require new features added in v1.4.0.</i></b><br/>
			Before v1.4.0, wings will not render.
		</div>
		<div class="notice bug legacy" style="display: none;margin-bottom:8px" id="bug-122-notice">
			<b><i>Selected options had bugs fixed in v1.2.2.</i></b><br/>
			Before v1.2.2:
			<ul>
			<li id="sides-bad-uvs">Sides, Floppy, and Behind modes had their back face texture locations swapped</li>
			<li id="around-bad-uvs">Around mode had the backs of the sides flipped horizontally</li>
			</ul>
		</div>
		<div class="notice bug legacy" style="display: none;margin-bottom:8px" id="bug-123-notice">
			<b><i>Selected options had bugs fixed in v1.2.3.</i></b><br/>
			Before v1.2.3:
			<ul>
			<li id="claws-bad-pos">Claws rendered one pixel off on the left arm for slim models</li>
			</ul>
		</div>
		<div class="notice bug" style="display: none;margin-bottom:8px" id="bug-140-notice">
			<b><i>Selected options had bugs fixed in v1.4.0.</i></b><br/>
			Before v1.4.0:
			<ul>
			<li id="chest-clip">Chests rendered through chestplates</li>
			<li id="claws-clip">Feet claws rendered through boots</li>
			</ul>
		</div>
		<br/><br/>
		<small>
			Copyright &copy; 2021 <a href="https://unascribed.com">Una "unascribed" Thompson</a><br/>
			This webpage and the code therein (excluding three.js and the TeaVM runtime) is licensed under the <a href="https://github.com/unascribed/Ears/blob/trunk/LICENSE">MIT License</a><br/>
			Powered by <a href="https://threejs.org">three.js</a> and <a href="https://teavm.org">TeaVM</a><br/>
			Sample skins are licensed under the <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>
		</small>
	</div>
	<script src="WebGL.js"></script>
	<script src="three.min.js"></script>
	<script src="ears-common.js?v=1.4.0"></script>
	<script>
	if (location.hash === "#debug") {
		window.EarsDebug = true;
	} else if (location.hash.indexOf("#debug=") === 0) {
		var li = location.hash.substring(7).split(",");
		window.EarsDebug = li;
	} else {
		window.EarsDebug = false;
	}
	window.addEventListener('hashchange', () => window.location.reload());
	var $ = (s) => document.querySelector(s);
	var $$ = (s) => document.querySelectorAll(s);
	
	initCommon();
	$("#version").textContent = "v"+window.commonVersion;
	
	let skinTexNeedsUpdate = false;
	function updateDpr() {
		let s = (64*(3*Math.ceil(devicePixelRatio)))/devicePixelRatio;
		$("#skin").style.width = s+"px";
		$("#skin").style.height = s+"px";
		s = (12*(3*Math.ceil(devicePixelRatio)))/devicePixelRatio;
		$("#wings").style.width = s+"px";
		$("#wings").style.height = s+"px";
	}
	function drawImage(ctx, img,
			dx1, dy1, dx2, dy2,
			sx1, sy1, sx2, sy2,
			observer) {
		var dx = dx1;
		var dy = dy1;
		var dw = dx2-dx1;
		var dh = dy2-dy1;
		
		var sx = sx1;
		var sy = sy1;
		var sw = sx2-sx1;
		var sh = sy2-sy1;
		
		ctx.save();
		ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
		ctx.restore();
	}
	function invert(obj) {
		let out = {};
		Object.entries(obj).forEach(([k, v]) => out[v] = k);
		return out;
	}
	rebuildQuads();
	
	function renderDegrees(val) {
		return val+"째";
	}
	
	function encodeDegrees(deg, allowZero) {
		if (deg == 0 && allowZero) return 0;
		let val = Math.round((deg/90)*128);
		if (val < 0) val++;
		if (val > 0) val--;
		val += 128;
		if (val === 0xD8) {
			// avoid running into Magic Blue by accident, which disables tail bending for compat
			// nobody will notice a 0.7째 inaccuracy
			val--;
		}
		if (val === 0) {
			// 0 means "this segment doesn't exist"
			val = 1;
		}
		return val;
	}
	function decodeDegrees(val) {
		if (val === 0) return 0;
		let deg = val-128;
		if (deg < 0) deg -= 1;
		if (deg >= 0) deg += 1;
		return (deg/128)*90;
	}
	
	let usingSample = false;
	let usingSampleWing = false;
	let earsElements = [];
	let tailBends = [$("#tail-bend-0"), $("#tail-bend-1"), $("#tail-bend-2"), $("#tail-bend-3")];
	let tailBendAngles = [$("#tail-bend-0-angle"), $("#tail-bend-1-angle"), $("#tail-bend-2-angle"), $("#tail-bend-3-angle")];
	
	function updateNotices() {
		let req121 = $("#req-121-notice");
		let req122 = $("#req-122-notice");
		let req123 = $("#req-123-notice");
		let req130 = $("#req-130-notice");
		let req140 = $("#req-140-notice");
		let req124 = $("#req-124-notice");
		let bug122 = $("#bug-122-notice");
		let bug123 = $("#bug-123-notice");
		let bug140 = $("#bug-140-notice");
		req121.style.display = "none";
		req122.style.display = "none";
		req123.style.display = "none";
		req124.style.display = "none";
		req130.style.display = "none";
		req140.style.display = "none";
		bug122.style.display = "none";
		bug123.style.display = "none";
		bug140.style.display = "none";
		$("#sides-bad-uvs").style.display = "none";
		$("#around-bad-uvs").style.display = "none";
		$("#claws-bad-pos").style.display = "none";
		$("#out-anchor-back").style.display = "none";
		$("#chest-clip").style.display = "none";
		$("#claws-clip").style.display = "none";
		$("#alfalfa-notice").style.display = alfalfaData.version > 0 ? "block" : "none";
		$("#alfalfa-notice-unneeded").style.display = "none";
		let earMode = $("#ear-mode").value;
		let earAnchor = $("#ear-anchor").value;
		if (earMode === "pink") {
			req121.style.display = "block";
		}
		if (earMode == "cyan") {
			bug122.style.display = "block";
			$("#around-bad-uvs").style.display = "list-item";
		}
		if (earMode === "green" || earMode == "purple" || earMode == "orange") {
			bug122.style.display = "block";
			$("#sides-bad-uvs").style.display = "list-item";
		}
		if (earMode === "purple2") {
			req123.style.display = "block";
			if (earAnchor === "red") {
				$("#out-anchor-back").style.display = "inline";
			}
		} 
		let protrusions = $("#protrusions").value;
		if (protrusions === "cyan" || protrusions === "green") {
			if ($("#slim-enabled").checked) {
				bug123.style.display = "block";
				$("#claws-bad-pos").style.display = "list-item";
			}
			bug140.style.display = "block";
			$("#claws-clip").style.display = "list-item";
		}
		let tailMode = $("#tail-mode").value;
		if (tailMode === "orange") {
			req124.style.display = "block";
		} else if ($("#tail-bend-0").value != 0) {
			req122.style.display = "block";
		}
		let req130Count = 0;
		if ($("#snout").checked) {
			req130.style.display = "block";
			$("#req-130-snouts").style.display = "inline";
			req130Count++;
		} else {
			$("#req-130-snouts").style.display = "none";
		}
		if ($("#chest").checked) {
			req130.style.display = "block";
			$("#req-130-chest").style.display = "inline";
			req130Count++;
			bug140.style.display = "block";
			$("#chest-clip").style.display = "list-item";
		} else {
			$("#req-130-chest").style.display = "none";
		}
		$("#req-130-and").style.display = req130Count > 1 ? "inline" : "none";
		let wingsMode = $("#wings-mode").value;
		if (wingsMode !== "red" && wingsMode !== "blue") {
			req140.style.display = "block";
		} else {
			$("#alfalfa-notice-unneeded").style.display = "block";
		}
	}
	
	rebuildGeom = null;
	async function rebuild() {
		if (usingSample) await rebuildSampleSkin();
		rebuildQuads();
		if (rebuildGeom) rebuildGeom();
		updateNotices();
		skinTexNeedsUpdate = true;
	}
	function wireElement(id, pixel) {
		let ele = document.getElementById(id);
		earsElements.push({ele, pixel});
		if (ele.nodeName === "SELECT") {
			ele.addEventListener("input", () => {
				let ctx = $("#skin").getContext("2d");
				ctx.fillStyle = magicPixelValues[ele.value];
				ctx.fillRect(0+Math.floor(pixel%4), 32+Math.floor(pixel/4), 1, 1);
				rebuild();
			});
		}
	}
	wireElement("ear-mode", 1);
	wireElement("ear-anchor", 2);
	wireElement("protrusions", 3);
	wireElement("tail-mode", 4);
	wireElement("tail-segments", -1);
	wireElement("unlock-angles", -1);
	wireElement("snout", -1);
	wireElement("chest", -1);
	wireElement("wings-mode", 8);
	wireElement("wing-upload", -1);
	async function updateSkin() {
		usingSample = false;
		usingSampleWing = false;
		let files = $("#skin-upload").files;
		if (!files || files.length == 0) return;
		let file = files[0];
		document.body.classList.add("loading");
		try {
			let bitmap = await createImageBitmap(file);
			if (bitmap.width != 64) {
				alert("This doesn't look like a Minecraft skin; the width is wrong. Needs to be 64px.");
				$("#skin-upload").value = null;
				return;
			}
			if (bitmap.height != 64 && bitmap.height != 32) {
				alert("This doesn't look like a Minecraft skin; the height is wrong. Needs to be 64px or 32px.");
				$("#skin-upload").value = null;
				return;
			}
			let ctx = $("#skin").getContext("2d");
			ctx.clearRect(0, 0, 64, 64);
			ctx.drawImage(bitmap, 0, 0);
			if (bitmap.height == 32) {
				console.log("Converting legacy skin.");
				drawImage(ctx, bitmap, 24, 48, 20, 52, 4, 16, 8, 20, null);
				drawImage(ctx, bitmap, 28, 48, 24, 52, 8, 16, 12, 20, null);
				drawImage(ctx, bitmap, 20, 52, 16, 64, 8, 20, 12, 32, null);
				drawImage(ctx, bitmap, 24, 52, 20, 64, 4, 20, 8, 32, null);
				drawImage(ctx, bitmap, 28, 52, 24, 64, 0, 20, 4, 32, null);
				drawImage(ctx, bitmap, 32, 52, 28, 64, 12, 20, 16, 32, null);
				drawImage(ctx, bitmap, 40, 48, 36, 52, 44, 16, 48, 20, null);
				drawImage(ctx, bitmap, 44, 48, 40, 52, 48, 16, 52, 20, null);
				drawImage(ctx, bitmap, 36, 52, 32, 64, 48, 20, 52, 32, null);
				drawImage(ctx, bitmap, 40, 52, 36, 64, 44, 20, 48, 32, null);
				drawImage(ctx, bitmap, 44, 52, 40, 64, 40, 20, 44, 32, null);
				drawImage(ctx, bitmap, 48, 52, 44, 64, 52, 20, 56, 32, null);
			}
			let earsEnabled = false;
			let earsData = new DataView(ctx.getImageData(0, 32, 4, 4).data.buffer);
			if (magicPixels[earsData.getUint32(0)] === "blue") {
				earsEnabled = true;
				earsElements.forEach((e) => {
					let ele = e.ele;
					ele.disabled = false;
					if (e.pixel !== -1) {
						let magic = magicPixels[String(earsData.getUint32(e.pixel*4))];
						if (ele.nodeName === "SELECT") {
							let valid = false;
							ele.querySelectorAll("option").forEach((opt) => {
								if (opt.value === magic) {
									valid = true;
								}
							});
							if (valid) {
								ele.value = magic;
							} else {
								ele.selectedIndex = 0;
							}
						} else if (ele.nodeName === "INPUT") {
							
						}
					}
				});
				let tailBend = earsData.getUint32(5*4);
				let tailBend0 = decodeDegrees(255-(tailBend&0x000000FF));
				let tailBend1 = 0;
				let tailBend2 = 0;
				let tailBend3 = 0;
				if (magicPixels[tailBend] !== "blue") {
					tailBend1 = decodeDegrees((tailBend&0xFF000000) >> 24);
					tailBend2 = decodeDegrees((tailBend&0x00FF0000) >> 16);
					tailBend3 = decodeDegrees((tailBend&0x0000FF00) >> 8);
				}
				$("#tail-bend-0").value = tailBend0;
				$("#tail-bend-0-angle").textContent = renderDegrees(tailBend0);
				for (let i = 1; i <= 3; i++) {
					$("#tail-bend-"+i).disabled = true;
					$("#tail-bend-"+i+"-angle").textContent = "";
				}
				let tailSegments = 1;
				if (tailBend1 != 0) {
					tailSegments++;
					$("#tail-bend-1").disabled = false;
					$("#tail-bend-1-angle").textContent = renderDegrees(tailBend1);
					if (tailBend2 != 0) {
						tailSegments++;
						$("#tail-bend-2").disabled = false;
						$("#tail-bend-2-angle").textContent = renderDegrees(tailBend2);
						if (tailBend3 != 0) {
							tailSegments++;
							$("#tail-bend-3").disabled = false;
							$("#tail-bend-3-angle").textContent = renderDegrees(tailBend3);
						}
					}
				}
				$("#tail-segments").value = tailSegments;
				$("#tail-bend-1").value = tailBend1;
				$("#tail-bend-2").value = tailBend2;
				$("#tail-bend-3").value = tailBend3;
				let snout = earsData.getUint32(6*4);
				let etc = earsData.getUint32(7*4);
				let snoutOffset = 0;
				let snoutWidth = 0;
				let snoutHeight = 0;
				let snoutDepth = 0;
				if (magicPixels[snout] !== "blue") {
					snoutOffset = ((etc>>16)&0xFF);
					snoutWidth = ((snout>>24)&0xFF);
					snoutHeight = ((snout>>16)&0xFF);
					snoutDepth = ((snout>>8)&0xFF);
					if (snoutOffset > 8-snoutHeight) snoutOffset = 8-snoutHeight;
					if (snoutWidth > 7) snoutWidth = 7;
					if (snoutHeight > 4) snoutHeight = 4;
					if (snoutDepth > 6) snoutDepth = 6;
				}
				if (snoutWidth !== 0 && snoutHeight !== 0 && snoutDepth !== 0) {
					$("#snout").checked = true;
					$("#snout-size").style.visibility = "visible";
					$("#snout-width").disabled = false;
					$("#snout-width").value = snoutWidth;
					$("#snout-width-value").textContent = snoutWidth;
					$("#snout-height").disabled = false;
					$("#snout-height").value = snoutHeight;
					$("#snout-height-value").textContent = snoutHeight;
					$("#snout-depth").disabled = false;
					$("#snout-depth").value = snoutDepth;
					$("#snout-depth-value").textContent = snoutDepth;
					$("#snout-offset").disabled = false;
					$("#snout-offset").value = snoutOffset;
					$("#snout-offset-value").textContent = snoutOffset;
				} else {
					$("#snout").checked = false;
					$("#snout-size").style.visibility = "hidden";
					$("#snout-width").disabled = true;
					$("#snout-height").disabled = true;
					$("#snout-depth").disabled = true;
					$("#snout-offset").disabled = true;
				}
				let chestSize = 0;
				if (magicPixels[etc] !== "blue") {
					chestSize = ((etc>>24)&0xFF)/128;
					if (chestSize > 1) chestSize = 1;
				}
				if (chestSize > 0) {
					$("#chest-outer").style.display = "table-row";
					$("#chest").checked = true;
					$("#chest-size").disabled = false;
					$("#chest-size").value = (chestSize*128)|0;
				} else {
					$("#chest-outer").style.display = "none";
					$("#chest").checked = false;
					$("#chest-size").disabled = true;
				}
			} else {
				earsElements.forEach((e) => {
					e.disabled = true;
				});
			}
			$("#ears-enabled").checked = earsEnabled;
			rebuildQuads();
			if (alfalfaData.wing) {
				$("#wing-upload").value = null;
				await new Promise((resolve, reject) => {
					let img = new Image();
					img.onload = () => {
						let ctx = $("#wings").getContext("2d");
						ctx.clearRect(0, 0, 12, 12);
						ctx.drawImage(img, 0, 0, 12, 12, 0, 0, 12, 12);
						resolve();
					};
					img.onerror = reject;
					img.src = 'data:image/png;base64,'+btoa(alfalfaData.wing);
				});
			}
			await rebuild();
		} finally {
			document.body.classList.remove("loading");
		}
	}
	async function updateWing() {
		usingSampleWing = false;
		let files = $("#wing-upload").files;
		if (!files || files.length == 0) return;
		let file = files[0];
		document.body.classList.add("loading");
		try {
			let bitmap = await createImageBitmap(file);
			if (bitmap.width != 12) {
				alert("This doesn't look like a Ears wing; the width is wrong. Needs to be 12px.");
				$("#wing-upload").value = null;
				return;
			}
			if (bitmap.height != 12) {
				alert("This doesn't look like a Ears wing; the height is wrong. Needs to be 12px.");
				$("#wing-upload").value = null;
				return;
			}
			let ctx = $("#wings").getContext("2d");
			ctx.clearRect(0, 0, 12, 12);
			ctx.drawImage(bitmap, 0, 0);
			encodeWingToAlfalfa();
			await rebuild();
		} finally {
			document.body.classList.remove("loading");
		}
	}
	function encodeWingToAlfalfa() {
		if (!!window.alfalfaData || !window.alfalfaData.version) {
			window.alfalfaData = {version:1};
		}
		let data = $("#wings").toDataURL('image/png');
		window.alfalfaData.wing = atob(data.substr(data.indexOf(',')+1));
		encodeAlfalfa();
	}
	$("#ears-enabled").addEventListener('input', () => {
		let en = $("#ears-enabled").checked;
		let ctx = $("#skin").getContext("2d");
		if (en) {
			ctx.fillStyle = magicPixelValues.blue;
			ctx.fillRect(0, 32, 4, 4);
		} else {
			ctx.clearRect(0, 32, 4, 4);
		}
		earsElements.forEach((e) => {
			e.ele.disabled = !en;
			if (en) {
				e.ele.dispatchEvent(new CustomEvent("input"));
			}
		});
		rebuild();
	});
	function rebuildSampleSkin() {
		return new Promise((resolve, reject) => {
			let img = new Image();
			img.onload = async () => {
				let ctx = $("#skin").getContext("2d");
				ctx.clearRect(4, 0, 60, 64);
				ctx.clearRect(0, 0, 4, 32);
				ctx.clearRect(0, 36, 4, 28);
				ctx.drawImage(img, 0, 0, 64, 64, 0, 0, 64, 64);
				let slim = $("#slim-enabled").checked;
				ctx.drawImage(img, slim ? 128 : 64, 0, 64, 64, 0, 0, 64, 64);
				if (!$("#head2-enabled").checked) {
					ctx.clearRect(32, 0, 32, 16);
				}
				if (!$("#torso2-enabled").checked) {
					ctx.clearRect(16, 32, 24, 16);
				}
				if (!$("#left_arm2-enabled").checked) {
					ctx.clearRect(48, 48, 16, 16);
				}
				if (!$("#right_arm2-enabled").checked) {
					ctx.clearRect(40, 32, 16, 16);
				}
				if (!$("#left_leg2-enabled").checked) {
					ctx.clearRect(0, 48, 16, 16);
				}
				if (!$("#right_leg2-enabled").checked) {
					ctx.clearRect(4, 32, 12, 16);
					ctx.clearRect(0, 36, 4, 12);
				}
				let earMode = $("#ear-mode").value;
				if (earMode === "blue") {
					ctx.drawImage(img, 192, 0, 64, 64, 0, 0, 64, 64);
				} else if (earMode === "cyan") {
					ctx.drawImage(img, 0, 64, 64, 64, 0, 0, 64, 64);
				} else if (earMode === "green" || earMode == "purple" || earMode == "orange" || earMode == "pink" || earMode === "purple2") {
					ctx.drawImage(img, 64, 64, 64, 64, 0, 0, 64, 64);
				}
				if ($("#tail-mode").value !== "red") {
					ctx.drawImage(img, 0, 128, 64, 64, 0, 0, 64, 64);
				}
				let protrusions = $("#protrusions").value;
				if (protrusions === "cyan" || protrusions === "purple") {
					ctx.drawImage(img, 128, 64, 64, 64, 0, 0, 64, 64);
				}
				if (protrusions === "cyan" || protrusions === "green") {
					ctx.drawImage(img, 192, 64, 64, 64, 0, 0, 64, 64);
				}
				if ($("#snout").checked) {
					let width = Number($("#snout-width").value);
					let height = Number($("#snout-height").value);
					let depth = Number($("#snout-depth").value);
					ctx.fillStyle = '#FF0000';
					ctx.fillRect(0, 0, width, 1);
					ctx.fillStyle = '#FFAA00';
					ctx.fillRect(0, 1, width, 1);
					ctx.fillStyle = '#FFFFFF';
					ctx.fillRect(0, 2, width, height);
					ctx.fillStyle = '#FF00FF';
					ctx.fillRect(0, 2+height, width, 1);
					ctx.fillStyle = '#00FFFF';
					ctx.fillRect(0, 2+height+1, width, 1);
					ctx.fillStyle = '#00FF00';
					ctx.fillRect(7, 0, 1, height);
					ctx.fillStyle = '#0000FF';
					ctx.fillRect(7, 4, 1, height);
					ctx.fillStyle = '#FFFFFF';
				}
				if ($("#chest").checked) {
					ctx.drawImage(img, 64, 128, 64, 64, 0, 0, 64, 64);
				}
				if (usingSampleWing) {
					let wingsCtx = $("#wings").getContext("2d");
					wingsCtx.clearRect(0, 0, 12, 12);
					let wingsMode = $("#wings-mode").value;
					if (wingsMode !== "red" && wingsMode !== "blue") {
						wingsCtx.drawImage(img, 0, 192, 12, 12, 0, 0, 12, 12);
						encodeWingToAlfalfa();
					} else {
						window.alfalfaData = {version:0};
						encodeAlfalfa();
					}
				} else {
					encodeWingToAlfalfa();
				}
				resolve();
			};
			img.onerror = reject;
			img.src = 'sample_skin_atlas.png';
		});
	}
	$("#sample").addEventListener('click', () => {
		usingSample = true;
		usingSampleWing = true;
		rebuild();
	});
	$("#slim-enabled").addEventListener("change", (e) => {
		rebuild();
	});
	["head", "torso", "left_arm", "right_arm", "left_leg", "right_leg"].forEach((n) => {
		$("#"+n+"2-enabled").addEventListener("change", (e) => {
			if (usingSample) rebuild();
		});
	});
	function updateTailBendPixel() {
		let ctx = $("#skin").getContext("2d");
		let scratch = ctx.createImageData(1, 1);
		let segs = $("#tail-segments").value;
		for (let i = 0; i < segs; i++) {
			let v = encodeDegrees(tailBends[i].value, i == 0);
			if (i > 0) {
				scratch.data[i-1] = (v&0xFF);
			} else {
				let a = (255-v)&0xFF;
				if (a < 0) a = 1;
				scratch.data[3] = a;
			}
		}
		ctx.putImageData(scratch, 1, 33);
		rebuild();
	}
	$("#unlock-angles").addEventListener("input", () => {
		let en = $("#unlock-angles").checked;
		tailBends.forEach((e) => {
			e.step = en ? 1 : 15;
		});
	});
	$("#tail-segments").addEventListener("input", () => {
		let en = $("#ears-enabled").checked;
		tailBends.forEach((e, i) => {
			if (en) {
				e.disabled = $("#tail-segments").value <= i;
				if (!e.disabled) {
					tailBendAngles[i].textContent = renderDegrees(e.value);
				} else {
					tailBendAngles[i].textContent = "";
				}
			} else {
				e.disabled = true;
				tailBendAngles[i].textContent = "";
			}
		});
		updateTailBendPixel();
	});
	tailBends.forEach((e, i) => {
		e.addEventListener("input", () => {
			tailBendAngles[i].textContent = renderDegrees(e.value);
			updateTailBendPixel();
		});
	});
	$("#snout").addEventListener('input', () => {
		let en = $("#snout").checked;
		$("#snout-width").disabled = !en;
		$("#snout-height").disabled = !en;
		$("#snout-depth").disabled = !en;
		$("#snout-offset").disabled = !en;
		$("#snout-size").style.visibility = en ? "visible" : "hidden";
		updateSnoutAndEtcPixel();
	});
	['width', 'height', 'depth', 'offset'].forEach((n) => {
		$("#snout-"+n).addEventListener('input', () => {
			$("#snout-"+n+"-value").textContent = $("#snout-"+n).value;
			updateSnoutAndEtcPixel();
		});
	});
	function updateSnoutAndEtcPixel() {
		let ctx = $("#skin").getContext("2d");
		let scratch = ctx.createImageData(2, 1);
		let en = $("#snout").checked;
		let width = en ? $("#snout-width").value : 0;
		let height = en ? $("#snout-height").value : 0;
		let depth = en ? $("#snout-depth").value : 0;
		$("#snout-offset").max = 8-height;
		let offset = en ? $("#snout-offset").value : 0;
		if (offset > 8-height) offset = 8-height;
		scratch.data[0] = width;
		scratch.data[1] = height;
		scratch.data[2] = depth;
		scratch.data[3] = 255;
		scratch.data[4] = $("#chest").checked ? $("#chest-size").value : 0;
		scratch.data[5] = offset;
		scratch.data[6] = 0;
		scratch.data[7] = 255;
		ctx.putImageData(scratch, 2, 33);
		rebuild();
	}
	$("#chest").addEventListener('input', () => {
		let en = $("#chest").checked;
		$("#chest-size").disabled = !en;
		updateSnoutAndEtcPixel();
		rebuild();
	});
	$("#chest-size").addEventListener('input', () => {
		let ctx = $("#skin").getContext("2d");
		updateSnoutAndEtcPixel();
		rebuild();
	});
	$("#skin-upload").addEventListener('change', () => updateSkin());
	$("#wing-upload").addEventListener('change', () => updateWing());
	$("#remove-alfalfa").addEventListener('click', () => {
		if (usingSample && !usingSampleWing) {
			usingSampleWing = true;
		}
		$("#wings").getContext('2d').clearRect(0, 0, 12, 12);
		window.alfalfaData = {version:0};
		encodeAlfalfa();
		rebuild();
	});
	window.addEventListener("resize", () => updateDpr());
	updateDpr();
	updateSkin();

	if (WEBGL.isWebGLAvailable()) {
		let scene = new THREE.Scene();
		let camera = new THREE.PerspectiveCamera(45, 512/896, 0.1, 1000);
		let renderer = new THREE.WebGLRenderer({
			powerPreference: "low-power",
			failIfMajorPerformanceCaveat: false,
			antialias: false
		});
		window.addEventListener("resize", () => renderer.setPixelRatio(window.devicePixelRatio));
		renderer.autoClear = true;
		renderer.setSize(512, 896);
		let dragging = false;
		let yaw = 60;
		let pitch = 15;
		let zoom = 65;
		$("#three").addEventListener("mousedown", (e) => {
			if (e.button === 0) {
				e.preventDefault();
				dragging = true;
			}
		});
		$("#three").addEventListener("mousemove", (e) => {
			if (e.button === 0) {
				e.preventDefault();
				if (dragging) {
					yaw = (yaw+e.movementX)%360;
					pitch = pitch+e.movementY;
					if (pitch < -89) pitch = -89;
					if (pitch > 89) pitch = 89;
				}
			}
		});
		$("#three").addEventListener("mouseup", (e) => {
			if (e.button === 0) {
				e.preventDefault();
				dragging = false;
			}
		});
		$("#three").addEventListener("wheel", (e) => {
			e.preventDefault();
			zoom += e.deltaY/8;
			if (zoom < 10) zoom = 10;
			if (zoom > 120) zoom = 120;
		});
		$("#three").appendChild(renderer.domElement);
		
		let skinTex = new THREE.CanvasTexture(
			$("#skin"), THREE.UVMapping,
			THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping,
			THREE.NearestFilter, THREE.NearestFilter);
		
		let wingsTex = new THREE.CanvasTexture(
			$("#wings"), THREE.UVMapping,
			THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping,
			THREE.NearestFilter, THREE.NearestFilter);
			
		let textures = {
			skin: skinTex,
			wing: wingsTex
		}
		
		let mat = new THREE.MeshLambertMaterial({
			reflectivity: -1,
			flatShading: true,
			fog: false,
			refractionRatio: 0,
			color: 0xFFFFFF,
			map: skinTex
		});
		let matOverlay = new THREE.MeshLambertMaterial({
			reflectivity: -1,
			flatShading: true,
			fog: false,
			refractionRatio: 0,
			color: 0xFFFFFF,
			map: skinTex,
			blending: THREE.NormalBlending,
			side: THREE.DoubleSide,
			alphaTest: 0.1,
			transparent: true
		});
		
		let earsMatParams = {
			reflectivity: -1,
			flatShading: true,
			fog: false,
			refractionRatio: 0,
			color: 0xFFFFFF,
			blending: THREE.NormalBlending,
			alphaTest: 0.1,
			transparent: true
		};
		
		let uvDiv = 64;
		
		function makeUVs(minU, minV, maxU, maxV) {
			return [
				new THREE.Vector2(minU/uvDiv, 1-maxV/uvDiv),
				new THREE.Vector2(maxU/uvDiv, 1-maxV/uvDiv),
				new THREE.Vector2(maxU/uvDiv, 1-minV/uvDiv),
				new THREE.Vector2(minU/uvDiv, 1-minV/uvDiv)
			];
		}
		
		let meshes = {};
		
		function bodyPart(name, x, y, z, w, h, d, u, v, overlay, rotX, rotY, rotZ) {
			let grow = overlay ? name === "head2" ? 0.5 : 0.25 : 0;
			
			let top = makeUVs(u+d, v, u+d+w, v+d);
			let bottom = makeUVs(u+d+w, v, u+d+w+w, v+d);
			let left = makeUVs(u, v+d, u+d, v+d+h);
			let front = makeUVs(u+d, v+d, u+d+w, v+d+h);
			let right = makeUVs(u+d+w, v+d, u+d+w+d, v+d+h);
			let back = makeUVs(u+d+w+d, v+d, u+d+w+d+w, v+d+h);
			let geom = new THREE.BoxGeometry((w+(grow*2)), (h+(grow*2)), (d+(grow*2)));
			geom.faceVertexUvs[0] = [
					[right[3], right[0], right[2]],
					[right[0], right[1], right[2]],
					[left[3], left[0], left[2]],
					[left[0], left[1], left[2]],
					[top[3], top[0], top[2]],
					[top[0], top[1], top[2]],
					[bottom[0], bottom[3], bottom[1]],
					[bottom[3], bottom[2], bottom[1]],
					[front[3], front[0], front[2]],
					[front[0], front[1], front[2]],
					[back[3], back[0], back[2]],
					[back[0], back[1], back[2]]
			];
			let mesh = new THREE.Mesh(geom, overlay ? matOverlay : mat);
			mesh.renderOrder = overlay ? 1 : 0;
			mesh.position.set(x, y, z);
			if (rotX || rotY || rotZ) {
				mesh.rotation.set(THREE.Math.degToRad(rotX), THREE.Math.degToRad(rotY), THREE.Math.degToRad(rotZ));
			}
			meshes[name] = mesh;
			return mesh;
		}
		
		function addToScene(m) {
			// so I can comment this out easily
			scene.add(m);
		}
		
		addToScene(bodyPart("head",
				0, 10, 0,
				8, 8, 8,
				0, 0,
				false,
				0, 20, 0));
		addToScene(bodyPart("head2",
				0, 10, 0,
				8, 8, 8,
				32, 0,
				true,
				0, 20, 0));
		
		addToScene(bodyPart("torso",
				0, 0, 0,
				8, 12, 4,
				16, 16,
				false));
		addToScene(bodyPart("torso2",
				0, 0, 0,
				8, 12, 4,
				16, 32,
				true));
		
		function addArms() {
			if ($("#slim-enabled").checked) {
				addToScene(bodyPart("right_arm",
						-5.5, 0, 0,
						3, 12, 4,
						40, 16,
						false,
						-10, 0, 0));
				addToScene(bodyPart("right_arm2",
						-5.5, 0, 0,
						3, 12, 4,
						40, 32,
						true,
						-10, 0, 0));
				
				addToScene(bodyPart("left_arm",
						5.5, 0, 0,
						3, 12, 4,
						32, 48,
						false,
						10, 0, 0));
				addToScene(bodyPart("left_arm2",
						5.5, 0, 0,
						3, 12, 4,
						48, 48,
						true,
						10, 0, 0));
			} else {
				addToScene(bodyPart("right_arm",
						-6, 0, 0,
						4, 12, 4,
						40, 16,
						false,
						-10, 0, 0));
				addToScene(bodyPart("right_arm2",
						-6, 0, 0,
						4, 12, 4,
						40, 32,
						true,
						-10, 0, 0));
				
				addToScene(bodyPart("left_arm",
						6, 0, 0,
						4, 12, 4,
						32, 48,
						false,
						10, 0, 0));
				addToScene(bodyPart("left_arm2",
						6, 0, 0,
						4, 12, 4,
						48, 48,
						true,
						10, 0, 0));
			}
		}
		
		addArms();
		
		addToScene(bodyPart("right_leg",
				-2, -12, 0,
				4, 12, 4,
				0, 16,
				false,
				0, 0, 0));
		addToScene(bodyPart("right_leg2",
				-2, -12, 0,
				4, 12, 4,
				0, 32,
				true,
				0, 0, 0));
		
		addToScene(bodyPart("left_leg",
				2, -12, 0,
				4, 12, 4,
				16, 48,
				false,
				0, 0, 0));
		addToScene(bodyPart("left_leg2",
				2, -12, 0,
				4, 12, 4,
				0, 48,
				true,
				0, 0, 0));
		
		$("#slim-enabled").addEventListener("change", (e) => {
			scene.remove(meshes["left_arm"]);
			scene.remove(meshes["left_arm2"]);
			scene.remove(meshes["right_arm"]);
			scene.remove(meshes["right_arm2"]);
			addArms();
			rebuildQuads();
			if (rebuildGeom) rebuildGeom();
		});

		function convertUV(arr) {
			return new THREE.Vector2(arr[0], 1-arr[1]);
		}
		
		let earsMeshes = [];
		rebuildGeom = function() {
			earsMeshes.forEach((mesh) => {
				scene.remove(mesh);
			});
			earsMeshes = [];
			renderObjects.forEach((o) => {
				let mat = new THREE.Matrix4().makeScale(1, 1, -1);
				o.moves.forEach((m) => {
					if (m.type === "anchor") {
						let tgt = meshes[m.part];
						if (!tgt) {
							console.warn("Unknown body part "+m.part+" while processing render object move", m);
							return;
						}
						mat.multiply(new THREE.Matrix4().makeTranslation(tgt.position.x, tgt.position.y, tgt.position.z));
						mat.multiply(new THREE.Matrix4().makeRotationZ(-tgt.rotation.z));
						mat.multiply(new THREE.Matrix4().makeRotationY(-tgt.rotation.y));
						mat.multiply(new THREE.Matrix4().makeRotationX(-tgt.rotation.x));
						mat.multiply(new THREE.Matrix4().makeTranslation(-tgt.geometry.parameters.width/2, -tgt.geometry.parameters.height/2, -tgt.geometry.parameters.depth/2));
					} else if (m.type === "translate") {
						mat.multiply(new THREE.Matrix4().makeTranslation(m.x, -m.y, m.z));
					} else if (m.type === "scale") {
						mat.multiply(new THREE.Matrix4().makeScale(m.x, m.y, m.z));
					} else if (m.type === "rotate") {
						mat.multiply(new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(-m.x, m.y, -m.z), THREE.Math.degToRad(m.ang)));
					} else {
						console.warn("Unknown type "+m.type+" while processing render object move", m);
					}
				});
				if (o.type === "quad") {
					let geom = new THREE.PlaneGeometry(o.width, o.height);
					geom.faceVertexUvs[0] = [
						[convertUV(o.uvs[3]), convertUV(o.uvs[0]), convertUV(o.uvs[2])],
						[convertUV(o.uvs[0]), convertUV(o.uvs[1]), convertUV(o.uvs[2])]
					];
					geom.translate(o.width/2, -o.height/2, 0);
					geom.applyMatrix4(mat);
					geom.computeVertexNormals();
					let material = new THREE.MeshLambertMaterial({
						...earsMatParams,
						side: o.back ? THREE.BackSide : THREE.FrontSide,
						map: textures[o.texture]
					});
					let mesh = new THREE.Mesh(geom, material);
					mesh.renderOrder = 0;
					earsMeshes.push(mesh);
					scene.add(mesh);
				} else if (o.type === "point") {
					let geom = new THREE.Geometry();
					geom.vertices.push(new THREE.Vector3(0, 0, 0));
					geom.applyMatrix4(mat);
					let points = new THREE.Points(geom, new THREE.PointsMaterial({
						color: o.color,
						size: 2
					}));
					earsMeshes.push(points);
					scene.add(points);
				} else {
					console.warn("Unknown type "+o.type+" while processing render object", o);
				}
			});
		};
		rebuildGeom();
		
		// standard item lighting

		scene.add(new THREE.AmbientLight(new THREE.Color(0.3, 0.3, 0.3)));
				
		let light0 = new THREE.DirectionalLight(new THREE.Color(0.6, 0.6, 0.6), 1);
		light0.position.set(0.3, 1, -0.9);
		light0.position.normalize();
		scene.add(light0);
		let light1 = new THREE.DirectionalLight(new THREE.Color(0.6, 0.6, 0.6), 1);
		light1.position.set(-0.3, 1, 0.9);
		light1.position.normalize();
		scene.add(light1);
		
		let lastRender = performance.now();
		
		function render() {
			let t = performance.now()/1000;
			let d = (performance.now()-lastRender)/1000;
			lastRender = performance.now();
			requestAnimationFrame(render);
			
			if (skinTexNeedsUpdate) {
				skinTex.needsUpdate = true;
				wingsTex.needsUpdate = true;
				skinTexNeedsUpdate = false;
			}
			
			scene.background = new THREE.Color(getComputedStyle(document.body).backgroundColor);
			
			Object.entries(meshes).forEach(([name, mesh]) => {
				let ele = document.getElementById(name+"-enabled");
				if (ele) {
					mesh.visible = ele.checked;
				}
			});
			
			let pRot = Math.sin(THREE.Math.degToRad(pitch));
			let p = 1-Math.abs(pRot);
			camera.position.set(Math.cos(THREE.Math.degToRad(yaw))*p, pRot, Math.sin(THREE.Math.degToRad(yaw))*p);
			camera.position.normalize();
			camera.position.x *= zoom;
			camera.position.y *= zoom;
			camera.position.z *= zoom;
			camera.lookAt(new THREE.Vector3(0, 0, 0));
			
			renderer.render(scene, camera);
		}
		requestAnimationFrame(render);
	} else {
		$("#three").appendChild(WEBGL.getWebGLErrorMessage());
	}
	</script>
</body>
</html>
